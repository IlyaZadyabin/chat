// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i chat/chat_server/internal/repository.ChatRepository -o chat_repository_mock.go -n ChatRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ChatRepositoryMock implements mm_repository.ChatRepository
type ChatRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcChatExists          func(ctx context.Context, chatID int64) (b1 bool, err error)
	funcChatExistsOrigin    string
	inspectFuncChatExists   func(ctx context.Context, chatID int64)
	afterChatExistsCounter  uint64
	beforeChatExistsCounter uint64
	ChatExistsMock          mChatRepositoryMockChatExists

	funcCreateChat          func(ctx context.Context, usernames []string) (i1 int64, err error)
	funcCreateChatOrigin    string
	inspectFuncCreateChat   func(ctx context.Context, usernames []string)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mChatRepositoryMockCreateChat

	funcDeleteChat          func(ctx context.Context, chatID int64) (err error)
	funcDeleteChatOrigin    string
	inspectFuncDeleteChat   func(ctx context.Context, chatID int64)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mChatRepositoryMockDeleteChat

	funcGetChatUsers          func(ctx context.Context, chatID int64) (sa1 []string, err error)
	funcGetChatUsersOrigin    string
	inspectFuncGetChatUsers   func(ctx context.Context, chatID int64)
	afterGetChatUsersCounter  uint64
	beforeGetChatUsersCounter uint64
	GetChatUsersMock          mChatRepositoryMockGetChatUsers

	funcSendMessage          func(ctx context.Context, fromUser string, text string, ts time.Time) (err error)
	funcSendMessageOrigin    string
	inspectFuncSendMessage   func(ctx context.Context, fromUser string, text string, ts time.Time)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatRepositoryMockSendMessage
}

// NewChatRepositoryMock returns a mock for mm_repository.ChatRepository
func NewChatRepositoryMock(t minimock.Tester) *ChatRepositoryMock {
	m := &ChatRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChatExistsMock = mChatRepositoryMockChatExists{mock: m}
	m.ChatExistsMock.callArgs = []*ChatRepositoryMockChatExistsParams{}

	m.CreateChatMock = mChatRepositoryMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*ChatRepositoryMockCreateChatParams{}

	m.DeleteChatMock = mChatRepositoryMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*ChatRepositoryMockDeleteChatParams{}

	m.GetChatUsersMock = mChatRepositoryMockGetChatUsers{mock: m}
	m.GetChatUsersMock.callArgs = []*ChatRepositoryMockGetChatUsersParams{}

	m.SendMessageMock = mChatRepositoryMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatRepositoryMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatRepositoryMockChatExists struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockChatExistsExpectation
	expectations       []*ChatRepositoryMockChatExistsExpectation

	callArgs []*ChatRepositoryMockChatExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryMockChatExistsExpectation specifies expectation struct of the ChatRepository.ChatExists
type ChatRepositoryMockChatExistsExpectation struct {
	mock               *ChatRepositoryMock
	params             *ChatRepositoryMockChatExistsParams
	paramPtrs          *ChatRepositoryMockChatExistsParamPtrs
	expectationOrigins ChatRepositoryMockChatExistsExpectationOrigins
	results            *ChatRepositoryMockChatExistsResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryMockChatExistsParams contains parameters of the ChatRepository.ChatExists
type ChatRepositoryMockChatExistsParams struct {
	ctx    context.Context
	chatID int64
}

// ChatRepositoryMockChatExistsParamPtrs contains pointers to parameters of the ChatRepository.ChatExists
type ChatRepositoryMockChatExistsParamPtrs struct {
	ctx    *context.Context
	chatID *int64
}

// ChatRepositoryMockChatExistsResults contains results of the ChatRepository.ChatExists
type ChatRepositoryMockChatExistsResults struct {
	b1  bool
	err error
}

// ChatRepositoryMockChatExistsOrigins contains origins of expectations of the ChatRepository.ChatExists
type ChatRepositoryMockChatExistsExpectationOrigins struct {
	origin       string
	originCtx    string
	originChatID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmChatExists *mChatRepositoryMockChatExists) Optional() *mChatRepositoryMockChatExists {
	mmChatExists.optional = true
	return mmChatExists
}

// Expect sets up expected params for ChatRepository.ChatExists
func (mmChatExists *mChatRepositoryMockChatExists) Expect(ctx context.Context, chatID int64) *mChatRepositoryMockChatExists {
	if mmChatExists.mock.funcChatExists != nil {
		mmChatExists.mock.t.Fatalf("ChatRepositoryMock.ChatExists mock is already set by Set")
	}

	if mmChatExists.defaultExpectation == nil {
		mmChatExists.defaultExpectation = &ChatRepositoryMockChatExistsExpectation{}
	}

	if mmChatExists.defaultExpectation.paramPtrs != nil {
		mmChatExists.mock.t.Fatalf("ChatRepositoryMock.ChatExists mock is already set by ExpectParams functions")
	}

	mmChatExists.defaultExpectation.params = &ChatRepositoryMockChatExistsParams{ctx, chatID}
	mmChatExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmChatExists.expectations {
		if minimock.Equal(e.params, mmChatExists.defaultExpectation.params) {
			mmChatExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChatExists.defaultExpectation.params)
		}
	}

	return mmChatExists
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.ChatExists
func (mmChatExists *mChatRepositoryMockChatExists) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockChatExists {
	if mmChatExists.mock.funcChatExists != nil {
		mmChatExists.mock.t.Fatalf("ChatRepositoryMock.ChatExists mock is already set by Set")
	}

	if mmChatExists.defaultExpectation == nil {
		mmChatExists.defaultExpectation = &ChatRepositoryMockChatExistsExpectation{}
	}

	if mmChatExists.defaultExpectation.params != nil {
		mmChatExists.mock.t.Fatalf("ChatRepositoryMock.ChatExists mock is already set by Expect")
	}

	if mmChatExists.defaultExpectation.paramPtrs == nil {
		mmChatExists.defaultExpectation.paramPtrs = &ChatRepositoryMockChatExistsParamPtrs{}
	}
	mmChatExists.defaultExpectation.paramPtrs.ctx = &ctx
	mmChatExists.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmChatExists
}

// ExpectChatIDParam2 sets up expected param chatID for ChatRepository.ChatExists
func (mmChatExists *mChatRepositoryMockChatExists) ExpectChatIDParam2(chatID int64) *mChatRepositoryMockChatExists {
	if mmChatExists.mock.funcChatExists != nil {
		mmChatExists.mock.t.Fatalf("ChatRepositoryMock.ChatExists mock is already set by Set")
	}

	if mmChatExists.defaultExpectation == nil {
		mmChatExists.defaultExpectation = &ChatRepositoryMockChatExistsExpectation{}
	}

	if mmChatExists.defaultExpectation.params != nil {
		mmChatExists.mock.t.Fatalf("ChatRepositoryMock.ChatExists mock is already set by Expect")
	}

	if mmChatExists.defaultExpectation.paramPtrs == nil {
		mmChatExists.defaultExpectation.paramPtrs = &ChatRepositoryMockChatExistsParamPtrs{}
	}
	mmChatExists.defaultExpectation.paramPtrs.chatID = &chatID
	mmChatExists.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmChatExists
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.ChatExists
func (mmChatExists *mChatRepositoryMockChatExists) Inspect(f func(ctx context.Context, chatID int64)) *mChatRepositoryMockChatExists {
	if mmChatExists.mock.inspectFuncChatExists != nil {
		mmChatExists.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.ChatExists")
	}

	mmChatExists.mock.inspectFuncChatExists = f

	return mmChatExists
}

// Return sets up results that will be returned by ChatRepository.ChatExists
func (mmChatExists *mChatRepositoryMockChatExists) Return(b1 bool, err error) *ChatRepositoryMock {
	if mmChatExists.mock.funcChatExists != nil {
		mmChatExists.mock.t.Fatalf("ChatRepositoryMock.ChatExists mock is already set by Set")
	}

	if mmChatExists.defaultExpectation == nil {
		mmChatExists.defaultExpectation = &ChatRepositoryMockChatExistsExpectation{mock: mmChatExists.mock}
	}
	mmChatExists.defaultExpectation.results = &ChatRepositoryMockChatExistsResults{b1, err}
	mmChatExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmChatExists.mock
}

// Set uses given function f to mock the ChatRepository.ChatExists method
func (mmChatExists *mChatRepositoryMockChatExists) Set(f func(ctx context.Context, chatID int64) (b1 bool, err error)) *ChatRepositoryMock {
	if mmChatExists.defaultExpectation != nil {
		mmChatExists.mock.t.Fatalf("Default expectation is already set for the ChatRepository.ChatExists method")
	}

	if len(mmChatExists.expectations) > 0 {
		mmChatExists.mock.t.Fatalf("Some expectations are already set for the ChatRepository.ChatExists method")
	}

	mmChatExists.mock.funcChatExists = f
	mmChatExists.mock.funcChatExistsOrigin = minimock.CallerInfo(1)
	return mmChatExists.mock
}

// When sets expectation for the ChatRepository.ChatExists which will trigger the result defined by the following
// Then helper
func (mmChatExists *mChatRepositoryMockChatExists) When(ctx context.Context, chatID int64) *ChatRepositoryMockChatExistsExpectation {
	if mmChatExists.mock.funcChatExists != nil {
		mmChatExists.mock.t.Fatalf("ChatRepositoryMock.ChatExists mock is already set by Set")
	}

	expectation := &ChatRepositoryMockChatExistsExpectation{
		mock:               mmChatExists.mock,
		params:             &ChatRepositoryMockChatExistsParams{ctx, chatID},
		expectationOrigins: ChatRepositoryMockChatExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmChatExists.expectations = append(mmChatExists.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.ChatExists return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockChatExistsExpectation) Then(b1 bool, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockChatExistsResults{b1, err}
	return e.mock
}

// Times sets number of times ChatRepository.ChatExists should be invoked
func (mmChatExists *mChatRepositoryMockChatExists) Times(n uint64) *mChatRepositoryMockChatExists {
	if n == 0 {
		mmChatExists.mock.t.Fatalf("Times of ChatRepositoryMock.ChatExists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmChatExists.expectedInvocations, n)
	mmChatExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmChatExists
}

func (mmChatExists *mChatRepositoryMockChatExists) invocationsDone() bool {
	if len(mmChatExists.expectations) == 0 && mmChatExists.defaultExpectation == nil && mmChatExists.mock.funcChatExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmChatExists.mock.afterChatExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmChatExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ChatExists implements mm_repository.ChatRepository
func (mmChatExists *ChatRepositoryMock) ChatExists(ctx context.Context, chatID int64) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmChatExists.beforeChatExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmChatExists.afterChatExistsCounter, 1)

	mmChatExists.t.Helper()

	if mmChatExists.inspectFuncChatExists != nil {
		mmChatExists.inspectFuncChatExists(ctx, chatID)
	}

	mm_params := ChatRepositoryMockChatExistsParams{ctx, chatID}

	// Record call args
	mmChatExists.ChatExistsMock.mutex.Lock()
	mmChatExists.ChatExistsMock.callArgs = append(mmChatExists.ChatExistsMock.callArgs, &mm_params)
	mmChatExists.ChatExistsMock.mutex.Unlock()

	for _, e := range mmChatExists.ChatExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmChatExists.ChatExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChatExists.ChatExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmChatExists.ChatExistsMock.defaultExpectation.params
		mm_want_ptrs := mmChatExists.ChatExistsMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockChatExistsParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmChatExists.t.Errorf("ChatRepositoryMock.ChatExists got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChatExists.ChatExistsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmChatExists.t.Errorf("ChatRepositoryMock.ChatExists got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmChatExists.ChatExistsMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChatExists.t.Errorf("ChatRepositoryMock.ChatExists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmChatExists.ChatExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChatExists.ChatExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmChatExists.t.Fatal("No results are set for the ChatRepositoryMock.ChatExists")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmChatExists.funcChatExists != nil {
		return mmChatExists.funcChatExists(ctx, chatID)
	}
	mmChatExists.t.Fatalf("Unexpected call to ChatRepositoryMock.ChatExists. %v %v", ctx, chatID)
	return
}

// ChatExistsAfterCounter returns a count of finished ChatRepositoryMock.ChatExists invocations
func (mmChatExists *ChatRepositoryMock) ChatExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatExists.afterChatExistsCounter)
}

// ChatExistsBeforeCounter returns a count of ChatRepositoryMock.ChatExists invocations
func (mmChatExists *ChatRepositoryMock) ChatExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatExists.beforeChatExistsCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.ChatExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChatExists *mChatRepositoryMockChatExists) Calls() []*ChatRepositoryMockChatExistsParams {
	mmChatExists.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockChatExistsParams, len(mmChatExists.callArgs))
	copy(argCopy, mmChatExists.callArgs)

	mmChatExists.mutex.RUnlock()

	return argCopy
}

// MinimockChatExistsDone returns true if the count of the ChatExists invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockChatExistsDone() bool {
	if m.ChatExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ChatExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ChatExistsMock.invocationsDone()
}

// MinimockChatExistsInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockChatExistsInspect() {
	for _, e := range m.ChatExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.ChatExists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterChatExistsCounter := mm_atomic.LoadUint64(&m.afterChatExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ChatExistsMock.defaultExpectation != nil && afterChatExistsCounter < 1 {
		if m.ChatExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryMock.ChatExists at\n%s", m.ChatExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.ChatExists at\n%s with params: %#v", m.ChatExistsMock.defaultExpectation.expectationOrigins.origin, *m.ChatExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChatExists != nil && afterChatExistsCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryMock.ChatExists at\n%s", m.funcChatExistsOrigin)
	}

	if !m.ChatExistsMock.invocationsDone() && afterChatExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.ChatExists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ChatExistsMock.expectedInvocations), m.ChatExistsMock.expectedInvocationsOrigin, afterChatExistsCounter)
	}
}

type mChatRepositoryMockCreateChat struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockCreateChatExpectation
	expectations       []*ChatRepositoryMockCreateChatExpectation

	callArgs []*ChatRepositoryMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryMockCreateChatExpectation specifies expectation struct of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatExpectation struct {
	mock               *ChatRepositoryMock
	params             *ChatRepositoryMockCreateChatParams
	paramPtrs          *ChatRepositoryMockCreateChatParamPtrs
	expectationOrigins ChatRepositoryMockCreateChatExpectationOrigins
	results            *ChatRepositoryMockCreateChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryMockCreateChatParams contains parameters of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatParams struct {
	ctx       context.Context
	usernames []string
}

// ChatRepositoryMockCreateChatParamPtrs contains pointers to parameters of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatParamPtrs struct {
	ctx       *context.Context
	usernames *[]string
}

// ChatRepositoryMockCreateChatResults contains results of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatResults struct {
	i1  int64
	err error
}

// ChatRepositoryMockCreateChatOrigins contains origins of expectations of the ChatRepository.CreateChat
type ChatRepositoryMockCreateChatExpectationOrigins struct {
	origin          string
	originCtx       string
	originUsernames string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mChatRepositoryMockCreateChat) Optional() *mChatRepositoryMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Expect(ctx context.Context, usernames []string) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &ChatRepositoryMockCreateChatParams{ctx, usernames}
	mmCreateChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateChat
}

// ExpectUsernamesParam2 sets up expected param usernames for ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) ExpectUsernamesParam2(usernames []string) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &ChatRepositoryMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.usernames = &usernames
	mmCreateChat.defaultExpectation.expectationOrigins.originUsernames = minimock.CallerInfo(1)

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Inspect(f func(ctx context.Context, usernames []string)) *mChatRepositoryMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by ChatRepository.CreateChat
func (mmCreateChat *mChatRepositoryMockCreateChat) Return(i1 int64, err error) *ChatRepositoryMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &ChatRepositoryMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &ChatRepositoryMockCreateChatResults{i1, err}
	mmCreateChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// Set uses given function f to mock the ChatRepository.CreateChat method
func (mmCreateChat *mChatRepositoryMockCreateChat) Set(f func(ctx context.Context, usernames []string) (i1 int64, err error)) *ChatRepositoryMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	mmCreateChat.mock.funcCreateChatOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// When sets expectation for the ChatRepository.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mChatRepositoryMockCreateChat) When(ctx context.Context, usernames []string) *ChatRepositoryMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("ChatRepositoryMock.CreateChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockCreateChatExpectation{
		mock:               mmCreateChat.mock,
		params:             &ChatRepositoryMockCreateChatParams{ctx, usernames},
		expectationOrigins: ChatRepositoryMockCreateChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.CreateChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockCreateChatExpectation) Then(i1 int64, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockCreateChatResults{i1, err}
	return e.mock
}

// Times sets number of times ChatRepository.CreateChat should be invoked
func (mmCreateChat *mChatRepositoryMockCreateChat) Times(n uint64) *mChatRepositoryMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of ChatRepositoryMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	mmCreateChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateChat
}

func (mmCreateChat *mChatRepositoryMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements mm_repository.ChatRepository
func (mmCreateChat *ChatRepositoryMock) CreateChat(ctx context.Context, usernames []string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	mmCreateChat.t.Helper()

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, usernames)
	}

	mm_params := ChatRepositoryMockCreateChatParams{ctx, usernames}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockCreateChatParams{ctx, usernames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.usernames != nil && !minimock.Equal(*mm_want_ptrs.usernames, mm_got.usernames) {
				mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameter usernames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originUsernames, *mm_want_ptrs.usernames, mm_got.usernames, minimock.Diff(*mm_want_ptrs.usernames, mm_got.usernames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("ChatRepositoryMock.CreateChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the ChatRepositoryMock.CreateChat")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, usernames)
	}
	mmCreateChat.t.Fatalf("Unexpected call to ChatRepositoryMock.CreateChat. %v %v", ctx, usernames)
	return
}

// CreateChatAfterCounter returns a count of finished ChatRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of ChatRepositoryMock.CreateChat invocations
func (mmCreateChat *ChatRepositoryMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mChatRepositoryMockCreateChat) Calls() []*ChatRepositoryMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat at\n%s", m.CreateChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat at\n%s with params: %#v", m.CreateChatMock.defaultExpectation.expectationOrigins.origin, *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryMock.CreateChat at\n%s", m.funcCreateChatOrigin)
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.CreateChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), m.CreateChatMock.expectedInvocationsOrigin, afterCreateChatCounter)
	}
}

type mChatRepositoryMockDeleteChat struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockDeleteChatExpectation
	expectations       []*ChatRepositoryMockDeleteChatExpectation

	callArgs []*ChatRepositoryMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryMockDeleteChatExpectation specifies expectation struct of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatExpectation struct {
	mock               *ChatRepositoryMock
	params             *ChatRepositoryMockDeleteChatParams
	paramPtrs          *ChatRepositoryMockDeleteChatParamPtrs
	expectationOrigins ChatRepositoryMockDeleteChatExpectationOrigins
	results            *ChatRepositoryMockDeleteChatResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryMockDeleteChatParams contains parameters of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatParams struct {
	ctx    context.Context
	chatID int64
}

// ChatRepositoryMockDeleteChatParamPtrs contains pointers to parameters of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatParamPtrs struct {
	ctx    *context.Context
	chatID *int64
}

// ChatRepositoryMockDeleteChatResults contains results of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatResults struct {
	err error
}

// ChatRepositoryMockDeleteChatOrigins contains origins of expectations of the ChatRepository.DeleteChat
type ChatRepositoryMockDeleteChatExpectationOrigins struct {
	origin       string
	originCtx    string
	originChatID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Optional() *mChatRepositoryMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Expect(ctx context.Context, chatID int64) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &ChatRepositoryMockDeleteChatParams{ctx, chatID}
	mmDeleteChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChat
}

// ExpectChatIDParam2 sets up expected param chatID for ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) ExpectChatIDParam2(chatID int64) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &ChatRepositoryMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.chatID = &chatID
	mmDeleteChat.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Inspect(f func(ctx context.Context, chatID int64)) *mChatRepositoryMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by ChatRepository.DeleteChat
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Return(err error) *ChatRepositoryMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &ChatRepositoryMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &ChatRepositoryMockDeleteChatResults{err}
	mmDeleteChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// Set uses given function f to mock the ChatRepository.DeleteChat method
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Set(f func(ctx context.Context, chatID int64) (err error)) *ChatRepositoryMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the ChatRepository.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the ChatRepository.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	mmDeleteChat.mock.funcDeleteChatOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// When sets expectation for the ChatRepository.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mChatRepositoryMockDeleteChat) When(ctx context.Context, chatID int64) *ChatRepositoryMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("ChatRepositoryMock.DeleteChat mock is already set by Set")
	}

	expectation := &ChatRepositoryMockDeleteChatExpectation{
		mock:               mmDeleteChat.mock,
		params:             &ChatRepositoryMockDeleteChatParams{ctx, chatID},
		expectationOrigins: ChatRepositoryMockDeleteChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.DeleteChat return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockDeleteChatExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.DeleteChat should be invoked
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Times(n uint64) *mChatRepositoryMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of ChatRepositoryMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	mmDeleteChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChat
}

func (mmDeleteChat *mChatRepositoryMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements mm_repository.ChatRepository
func (mmDeleteChat *ChatRepositoryMock) DeleteChat(ctx context.Context, chatID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	mmDeleteChat.t.Helper()

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, chatID)
	}

	mm_params := ChatRepositoryMockDeleteChatParams{ctx, chatID}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockDeleteChatParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("ChatRepositoryMock.DeleteChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmDeleteChat.t.Errorf("ChatRepositoryMock.DeleteChat got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("ChatRepositoryMock.DeleteChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the ChatRepositoryMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, chatID)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to ChatRepositoryMock.DeleteChat. %v %v", ctx, chatID)
	return
}

// DeleteChatAfterCounter returns a count of finished ChatRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatRepositoryMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of ChatRepositoryMock.DeleteChat invocations
func (mmDeleteChat *ChatRepositoryMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mChatRepositoryMockDeleteChat) Calls() []*ChatRepositoryMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat at\n%s", m.DeleteChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat at\n%s with params: %#v", m.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryMock.DeleteChat at\n%s", m.funcDeleteChatOrigin)
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.DeleteChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), m.DeleteChatMock.expectedInvocationsOrigin, afterDeleteChatCounter)
	}
}

type mChatRepositoryMockGetChatUsers struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockGetChatUsersExpectation
	expectations       []*ChatRepositoryMockGetChatUsersExpectation

	callArgs []*ChatRepositoryMockGetChatUsersParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryMockGetChatUsersExpectation specifies expectation struct of the ChatRepository.GetChatUsers
type ChatRepositoryMockGetChatUsersExpectation struct {
	mock               *ChatRepositoryMock
	params             *ChatRepositoryMockGetChatUsersParams
	paramPtrs          *ChatRepositoryMockGetChatUsersParamPtrs
	expectationOrigins ChatRepositoryMockGetChatUsersExpectationOrigins
	results            *ChatRepositoryMockGetChatUsersResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryMockGetChatUsersParams contains parameters of the ChatRepository.GetChatUsers
type ChatRepositoryMockGetChatUsersParams struct {
	ctx    context.Context
	chatID int64
}

// ChatRepositoryMockGetChatUsersParamPtrs contains pointers to parameters of the ChatRepository.GetChatUsers
type ChatRepositoryMockGetChatUsersParamPtrs struct {
	ctx    *context.Context
	chatID *int64
}

// ChatRepositoryMockGetChatUsersResults contains results of the ChatRepository.GetChatUsers
type ChatRepositoryMockGetChatUsersResults struct {
	sa1 []string
	err error
}

// ChatRepositoryMockGetChatUsersOrigins contains origins of expectations of the ChatRepository.GetChatUsers
type ChatRepositoryMockGetChatUsersExpectationOrigins struct {
	origin       string
	originCtx    string
	originChatID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChatUsers *mChatRepositoryMockGetChatUsers) Optional() *mChatRepositoryMockGetChatUsers {
	mmGetChatUsers.optional = true
	return mmGetChatUsers
}

// Expect sets up expected params for ChatRepository.GetChatUsers
func (mmGetChatUsers *mChatRepositoryMockGetChatUsers) Expect(ctx context.Context, chatID int64) *mChatRepositoryMockGetChatUsers {
	if mmGetChatUsers.mock.funcGetChatUsers != nil {
		mmGetChatUsers.mock.t.Fatalf("ChatRepositoryMock.GetChatUsers mock is already set by Set")
	}

	if mmGetChatUsers.defaultExpectation == nil {
		mmGetChatUsers.defaultExpectation = &ChatRepositoryMockGetChatUsersExpectation{}
	}

	if mmGetChatUsers.defaultExpectation.paramPtrs != nil {
		mmGetChatUsers.mock.t.Fatalf("ChatRepositoryMock.GetChatUsers mock is already set by ExpectParams functions")
	}

	mmGetChatUsers.defaultExpectation.params = &ChatRepositoryMockGetChatUsersParams{ctx, chatID}
	mmGetChatUsers.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetChatUsers.expectations {
		if minimock.Equal(e.params, mmGetChatUsers.defaultExpectation.params) {
			mmGetChatUsers.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetChatUsers.defaultExpectation.params)
		}
	}

	return mmGetChatUsers
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.GetChatUsers
func (mmGetChatUsers *mChatRepositoryMockGetChatUsers) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockGetChatUsers {
	if mmGetChatUsers.mock.funcGetChatUsers != nil {
		mmGetChatUsers.mock.t.Fatalf("ChatRepositoryMock.GetChatUsers mock is already set by Set")
	}

	if mmGetChatUsers.defaultExpectation == nil {
		mmGetChatUsers.defaultExpectation = &ChatRepositoryMockGetChatUsersExpectation{}
	}

	if mmGetChatUsers.defaultExpectation.params != nil {
		mmGetChatUsers.mock.t.Fatalf("ChatRepositoryMock.GetChatUsers mock is already set by Expect")
	}

	if mmGetChatUsers.defaultExpectation.paramPtrs == nil {
		mmGetChatUsers.defaultExpectation.paramPtrs = &ChatRepositoryMockGetChatUsersParamPtrs{}
	}
	mmGetChatUsers.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetChatUsers.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetChatUsers
}

// ExpectChatIDParam2 sets up expected param chatID for ChatRepository.GetChatUsers
func (mmGetChatUsers *mChatRepositoryMockGetChatUsers) ExpectChatIDParam2(chatID int64) *mChatRepositoryMockGetChatUsers {
	if mmGetChatUsers.mock.funcGetChatUsers != nil {
		mmGetChatUsers.mock.t.Fatalf("ChatRepositoryMock.GetChatUsers mock is already set by Set")
	}

	if mmGetChatUsers.defaultExpectation == nil {
		mmGetChatUsers.defaultExpectation = &ChatRepositoryMockGetChatUsersExpectation{}
	}

	if mmGetChatUsers.defaultExpectation.params != nil {
		mmGetChatUsers.mock.t.Fatalf("ChatRepositoryMock.GetChatUsers mock is already set by Expect")
	}

	if mmGetChatUsers.defaultExpectation.paramPtrs == nil {
		mmGetChatUsers.defaultExpectation.paramPtrs = &ChatRepositoryMockGetChatUsersParamPtrs{}
	}
	mmGetChatUsers.defaultExpectation.paramPtrs.chatID = &chatID
	mmGetChatUsers.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmGetChatUsers
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.GetChatUsers
func (mmGetChatUsers *mChatRepositoryMockGetChatUsers) Inspect(f func(ctx context.Context, chatID int64)) *mChatRepositoryMockGetChatUsers {
	if mmGetChatUsers.mock.inspectFuncGetChatUsers != nil {
		mmGetChatUsers.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.GetChatUsers")
	}

	mmGetChatUsers.mock.inspectFuncGetChatUsers = f

	return mmGetChatUsers
}

// Return sets up results that will be returned by ChatRepository.GetChatUsers
func (mmGetChatUsers *mChatRepositoryMockGetChatUsers) Return(sa1 []string, err error) *ChatRepositoryMock {
	if mmGetChatUsers.mock.funcGetChatUsers != nil {
		mmGetChatUsers.mock.t.Fatalf("ChatRepositoryMock.GetChatUsers mock is already set by Set")
	}

	if mmGetChatUsers.defaultExpectation == nil {
		mmGetChatUsers.defaultExpectation = &ChatRepositoryMockGetChatUsersExpectation{mock: mmGetChatUsers.mock}
	}
	mmGetChatUsers.defaultExpectation.results = &ChatRepositoryMockGetChatUsersResults{sa1, err}
	mmGetChatUsers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChatUsers.mock
}

// Set uses given function f to mock the ChatRepository.GetChatUsers method
func (mmGetChatUsers *mChatRepositoryMockGetChatUsers) Set(f func(ctx context.Context, chatID int64) (sa1 []string, err error)) *ChatRepositoryMock {
	if mmGetChatUsers.defaultExpectation != nil {
		mmGetChatUsers.mock.t.Fatalf("Default expectation is already set for the ChatRepository.GetChatUsers method")
	}

	if len(mmGetChatUsers.expectations) > 0 {
		mmGetChatUsers.mock.t.Fatalf("Some expectations are already set for the ChatRepository.GetChatUsers method")
	}

	mmGetChatUsers.mock.funcGetChatUsers = f
	mmGetChatUsers.mock.funcGetChatUsersOrigin = minimock.CallerInfo(1)
	return mmGetChatUsers.mock
}

// When sets expectation for the ChatRepository.GetChatUsers which will trigger the result defined by the following
// Then helper
func (mmGetChatUsers *mChatRepositoryMockGetChatUsers) When(ctx context.Context, chatID int64) *ChatRepositoryMockGetChatUsersExpectation {
	if mmGetChatUsers.mock.funcGetChatUsers != nil {
		mmGetChatUsers.mock.t.Fatalf("ChatRepositoryMock.GetChatUsers mock is already set by Set")
	}

	expectation := &ChatRepositoryMockGetChatUsersExpectation{
		mock:               mmGetChatUsers.mock,
		params:             &ChatRepositoryMockGetChatUsersParams{ctx, chatID},
		expectationOrigins: ChatRepositoryMockGetChatUsersExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetChatUsers.expectations = append(mmGetChatUsers.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.GetChatUsers return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockGetChatUsersExpectation) Then(sa1 []string, err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockGetChatUsersResults{sa1, err}
	return e.mock
}

// Times sets number of times ChatRepository.GetChatUsers should be invoked
func (mmGetChatUsers *mChatRepositoryMockGetChatUsers) Times(n uint64) *mChatRepositoryMockGetChatUsers {
	if n == 0 {
		mmGetChatUsers.mock.t.Fatalf("Times of ChatRepositoryMock.GetChatUsers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChatUsers.expectedInvocations, n)
	mmGetChatUsers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChatUsers
}

func (mmGetChatUsers *mChatRepositoryMockGetChatUsers) invocationsDone() bool {
	if len(mmGetChatUsers.expectations) == 0 && mmGetChatUsers.defaultExpectation == nil && mmGetChatUsers.mock.funcGetChatUsers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChatUsers.mock.afterGetChatUsersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChatUsers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChatUsers implements mm_repository.ChatRepository
func (mmGetChatUsers *ChatRepositoryMock) GetChatUsers(ctx context.Context, chatID int64) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetChatUsers.beforeGetChatUsersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChatUsers.afterGetChatUsersCounter, 1)

	mmGetChatUsers.t.Helper()

	if mmGetChatUsers.inspectFuncGetChatUsers != nil {
		mmGetChatUsers.inspectFuncGetChatUsers(ctx, chatID)
	}

	mm_params := ChatRepositoryMockGetChatUsersParams{ctx, chatID}

	// Record call args
	mmGetChatUsers.GetChatUsersMock.mutex.Lock()
	mmGetChatUsers.GetChatUsersMock.callArgs = append(mmGetChatUsers.GetChatUsersMock.callArgs, &mm_params)
	mmGetChatUsers.GetChatUsersMock.mutex.Unlock()

	for _, e := range mmGetChatUsers.GetChatUsersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetChatUsers.GetChatUsersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChatUsers.GetChatUsersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetChatUsers.GetChatUsersMock.defaultExpectation.params
		mm_want_ptrs := mmGetChatUsers.GetChatUsersMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockGetChatUsersParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetChatUsers.t.Errorf("ChatRepositoryMock.GetChatUsers got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatUsers.GetChatUsersMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmGetChatUsers.t.Errorf("ChatRepositoryMock.GetChatUsers got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetChatUsers.GetChatUsersMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetChatUsers.t.Errorf("ChatRepositoryMock.GetChatUsers got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetChatUsers.GetChatUsersMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetChatUsers.GetChatUsersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChatUsers.t.Fatal("No results are set for the ChatRepositoryMock.GetChatUsers")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetChatUsers.funcGetChatUsers != nil {
		return mmGetChatUsers.funcGetChatUsers(ctx, chatID)
	}
	mmGetChatUsers.t.Fatalf("Unexpected call to ChatRepositoryMock.GetChatUsers. %v %v", ctx, chatID)
	return
}

// GetChatUsersAfterCounter returns a count of finished ChatRepositoryMock.GetChatUsers invocations
func (mmGetChatUsers *ChatRepositoryMock) GetChatUsersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatUsers.afterGetChatUsersCounter)
}

// GetChatUsersBeforeCounter returns a count of ChatRepositoryMock.GetChatUsers invocations
func (mmGetChatUsers *ChatRepositoryMock) GetChatUsersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChatUsers.beforeGetChatUsersCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.GetChatUsers.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetChatUsers *mChatRepositoryMockGetChatUsers) Calls() []*ChatRepositoryMockGetChatUsersParams {
	mmGetChatUsers.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockGetChatUsersParams, len(mmGetChatUsers.callArgs))
	copy(argCopy, mmGetChatUsers.callArgs)

	mmGetChatUsers.mutex.RUnlock()

	return argCopy
}

// MinimockGetChatUsersDone returns true if the count of the GetChatUsers invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockGetChatUsersDone() bool {
	if m.GetChatUsersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChatUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChatUsersMock.invocationsDone()
}

// MinimockGetChatUsersInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockGetChatUsersInspect() {
	for _, e := range m.GetChatUsersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.GetChatUsers at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetChatUsersCounter := mm_atomic.LoadUint64(&m.afterGetChatUsersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChatUsersMock.defaultExpectation != nil && afterGetChatUsersCounter < 1 {
		if m.GetChatUsersMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryMock.GetChatUsers at\n%s", m.GetChatUsersMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.GetChatUsers at\n%s with params: %#v", m.GetChatUsersMock.defaultExpectation.expectationOrigins.origin, *m.GetChatUsersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChatUsers != nil && afterGetChatUsersCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryMock.GetChatUsers at\n%s", m.funcGetChatUsersOrigin)
	}

	if !m.GetChatUsersMock.invocationsDone() && afterGetChatUsersCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.GetChatUsers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChatUsersMock.expectedInvocations), m.GetChatUsersMock.expectedInvocationsOrigin, afterGetChatUsersCounter)
	}
}

type mChatRepositoryMockSendMessage struct {
	optional           bool
	mock               *ChatRepositoryMock
	defaultExpectation *ChatRepositoryMockSendMessageExpectation
	expectations       []*ChatRepositoryMockSendMessageExpectation

	callArgs []*ChatRepositoryMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatRepositoryMockSendMessageExpectation specifies expectation struct of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageExpectation struct {
	mock               *ChatRepositoryMock
	params             *ChatRepositoryMockSendMessageParams
	paramPtrs          *ChatRepositoryMockSendMessageParamPtrs
	expectationOrigins ChatRepositoryMockSendMessageExpectationOrigins
	results            *ChatRepositoryMockSendMessageResults
	returnOrigin       string
	Counter            uint64
}

// ChatRepositoryMockSendMessageParams contains parameters of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageParams struct {
	ctx      context.Context
	fromUser string
	text     string
	ts       time.Time
}

// ChatRepositoryMockSendMessageParamPtrs contains pointers to parameters of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageParamPtrs struct {
	ctx      *context.Context
	fromUser *string
	text     *string
	ts       *time.Time
}

// ChatRepositoryMockSendMessageResults contains results of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageResults struct {
	err error
}

// ChatRepositoryMockSendMessageOrigins contains origins of expectations of the ChatRepository.SendMessage
type ChatRepositoryMockSendMessageExpectationOrigins struct {
	origin         string
	originCtx      string
	originFromUser string
	originText     string
	originTs       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mChatRepositoryMockSendMessage) Optional() *mChatRepositoryMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) Expect(ctx context.Context, fromUser string, text string, ts time.Time) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &ChatRepositoryMockSendMessageParams{ctx, fromUser, text, ts}
	mmSendMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) ExpectCtxParam1(ctx context.Context) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatRepositoryMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectFromUserParam2 sets up expected param fromUser for ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) ExpectFromUserParam2(fromUser string) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatRepositoryMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.fromUser = &fromUser
	mmSendMessage.defaultExpectation.expectationOrigins.originFromUser = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectTextParam3 sets up expected param text for ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) ExpectTextParam3(text string) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatRepositoryMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.text = &text
	mmSendMessage.defaultExpectation.expectationOrigins.originText = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectTsParam4 sets up expected param ts for ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) ExpectTsParam4(ts time.Time) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatRepositoryMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ts = &ts
	mmSendMessage.defaultExpectation.expectationOrigins.originTs = minimock.CallerInfo(1)

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) Inspect(f func(ctx context.Context, fromUser string, text string, ts time.Time)) *mChatRepositoryMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatRepositoryMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatRepository.SendMessage
func (mmSendMessage *mChatRepositoryMockSendMessage) Return(err error) *ChatRepositoryMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatRepositoryMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatRepositoryMockSendMessageResults{err}
	mmSendMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatRepository.SendMessage method
func (mmSendMessage *mChatRepositoryMockSendMessage) Set(f func(ctx context.Context, fromUser string, text string, ts time.Time) (err error)) *ChatRepositoryMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatRepository.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatRepository.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	mmSendMessage.mock.funcSendMessageOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// When sets expectation for the ChatRepository.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatRepositoryMockSendMessage) When(ctx context.Context, fromUser string, text string, ts time.Time) *ChatRepositoryMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatRepositoryMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatRepositoryMockSendMessageExpectation{
		mock:               mmSendMessage.mock,
		params:             &ChatRepositoryMockSendMessageParams{ctx, fromUser, text, ts},
		expectationOrigins: ChatRepositoryMockSendMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatRepository.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatRepositoryMockSendMessageExpectation) Then(err error) *ChatRepositoryMock {
	e.results = &ChatRepositoryMockSendMessageResults{err}
	return e.mock
}

// Times sets number of times ChatRepository.SendMessage should be invoked
func (mmSendMessage *mChatRepositoryMockSendMessage) Times(n uint64) *mChatRepositoryMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of ChatRepositoryMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	mmSendMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMessage
}

func (mmSendMessage *mChatRepositoryMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements mm_repository.ChatRepository
func (mmSendMessage *ChatRepositoryMock) SendMessage(ctx context.Context, fromUser string, text string, ts time.Time) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	mmSendMessage.t.Helper()

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, fromUser, text, ts)
	}

	mm_params := ChatRepositoryMockSendMessageParams{ctx, fromUser, text, ts}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatRepositoryMockSendMessageParams{ctx, fromUser, text, ts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessage.t.Errorf("ChatRepositoryMock.SendMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fromUser != nil && !minimock.Equal(*mm_want_ptrs.fromUser, mm_got.fromUser) {
				mmSendMessage.t.Errorf("ChatRepositoryMock.SendMessage got unexpected parameter fromUser, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originFromUser, *mm_want_ptrs.fromUser, mm_got.fromUser, minimock.Diff(*mm_want_ptrs.fromUser, mm_got.fromUser))
			}

			if mm_want_ptrs.text != nil && !minimock.Equal(*mm_want_ptrs.text, mm_got.text) {
				mmSendMessage.t.Errorf("ChatRepositoryMock.SendMessage got unexpected parameter text, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originText, *mm_want_ptrs.text, mm_got.text, minimock.Diff(*mm_want_ptrs.text, mm_got.text))
			}

			if mm_want_ptrs.ts != nil && !minimock.Equal(*mm_want_ptrs.ts, mm_got.ts) {
				mmSendMessage.t.Errorf("ChatRepositoryMock.SendMessage got unexpected parameter ts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originTs, *mm_want_ptrs.ts, mm_got.ts, minimock.Diff(*mm_want_ptrs.ts, mm_got.ts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatRepositoryMock.SendMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatRepositoryMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, fromUser, text, ts)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatRepositoryMock.SendMessage. %v %v %v %v", ctx, fromUser, text, ts)
	return
}

// SendMessageAfterCounter returns a count of finished ChatRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatRepositoryMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatRepositoryMock.SendMessage invocations
func (mmSendMessage *ChatRepositoryMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatRepositoryMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatRepositoryMockSendMessage) Calls() []*ChatRepositoryMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatRepositoryMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatRepositoryMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatRepositoryMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatRepositoryMock.SendMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatRepositoryMock.SendMessage at\n%s", m.SendMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatRepositoryMock.SendMessage at\n%s with params: %#v", m.SendMessageMock.defaultExpectation.expectationOrigins.origin, *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Errorf("Expected call to ChatRepositoryMock.SendMessage at\n%s", m.funcSendMessageOrigin)
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatRepositoryMock.SendMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), m.SendMessageMock.expectedInvocationsOrigin, afterSendMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockChatExistsInspect()

			m.MinimockCreateChatInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockGetChatUsersInspect()

			m.MinimockSendMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChatExistsDone() &&
		m.MinimockCreateChatDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockGetChatUsersDone() &&
		m.MinimockSendMessageDone()
}
